{
  "metadata": {
    "name": "reactjs-best-practices",
    "description": "Provides React.js best practices, patterns, and recommendations for building high-quality React applications. Use when you need guidance on hooks, performance optimization, state management, component design, or testing.",
    "metadata": {
      "category": "reactjs",
      "version": "1.0.0",
      "tags": [
        "react",
        "best-practices",
        "patterns",
        "guidelines",
        "typescript"
      ],
      "owner": "skills-kit-team",
      "originalSource": "https://github.com/your-org/skills-kit"
    },
    "category": "reactjs",
    "version": "1.0.0",
    "tags": [
      "react",
      "best-practices",
      "patterns",
      "guidelines",
      "typescript"
    ],
    "owner": "skills-kit-team",
    "originalSource": "https://github.com/your-org/skills-kit"
  },
  "content": "# React.js Best Practices\n\nThis skill provides comprehensive React.js best practices, patterns, and recommendations to help you build high-quality, maintainable React applications.\n\n## When to Use\n\nUse this skill when you need guidance on:\n\n- React hooks patterns and best practices\n- Performance optimization techniques\n- State management strategies\n- Component design principles\n- Testing approaches\n- Code organization and architecture\n\n## Topics Covered\n\n### 1. React Hooks Best Practices\n\n#### Rules of Hooks\n\n1. **Only call hooks at the top level** - Don't call hooks inside loops, conditions, or nested functions\n2. **Only call hooks from React functions** - Call hooks from React function components or custom hooks\n3. **Use exhaustive-deps rule** - Always include all dependencies in useEffect, useMemo, and useCallback\n\n#### Common Hooks Patterns\n\n**useState**\n\n- Use functional updates when the new state depends on the previous state\n- Initialize state with a function if the initial value is expensive to compute\n\n```tsx\n// ✅ Good: Functional update\nconst [count, setCount] = useState(0);\nsetCount((prev) => prev + 1);\n\n// ✅ Good: Expensive initial state\nconst [data, setData] = useState(() => expensiveComputation());\n```\n\n**useEffect**\n\n- Always specify dependencies\n- Clean up side effects (subscriptions, timers) in the return function\n- Use separate effects for unrelated concerns\n\n```tsx\n// ✅ Good: useEffect with cleanup\nuseEffect(() => {\n  const subscription = subscribe();\n  return () => subscription.unsubscribe();\n}, [deps]);\n\n// ❌ Bad: Missing dependencies\nuseEffect(() => {\n  fetchData(userId);\n}, []); // Missing userId dependency\n\n// ✅ Good: Include all dependencies\nuseEffect(() => {\n  fetchData(userId);\n}, [userId]);\n```\n\n**useMemo & useCallback**\n\n- Only use when you have a performance problem\n- Don't memoize everything - it has its own cost\n- useMemo for expensive calculations\n- useCallback for functions passed to memoized children\n\n```tsx\n// ✅ Good: Memoize expensive calculation\nconst expensiveValue = useMemo(() => {\n  return computeExpensiveValue(a, b);\n}, [a, b]);\n\n// ✅ Good: Memoize callback for memoized child\nconst handleClick = useCallback(() => {\n  doSomething(id);\n}, [id]);\n```\n\n### 2. Performance Optimization\n\n#### Best Practices\n\n1. **Use React.memo wisely** - Memoize components that render frequently with the same props\n2. **Code splitting** - Use React.lazy() and Suspense for route-based code splitting\n3. **Virtualize long lists** - Use libraries like react-window for long lists\n4. **Avoid inline object/function creation** - Creates new references on every render\n5. **Use production builds** - Always use production builds for deployment\n\n#### Optimization Techniques\n\n**Memoization**\n\n```tsx\n// ✅ Good: Memoized component\nconst ExpensiveComponent = React.memo(({ data }) => {\n  return <div>{/* render */}</div>;\n});\n\n// ❌ Bad: Inline object creation\n<Component style={{ color: \"red\" }} />;\n\n// ✅ Good: Extract to constant\nconst styles = { color: \"red\" };\n<Component style={styles} />;\n```\n\n**Code Splitting**\n\n```tsx\n// ✅ Good: Code splitting\nconst LazyComponent = React.lazy(() => import(\"./LazyComponent\"));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n}\n```\n\n### 3. State Management\n\n#### Guidelines\n\n1. **Lift state up** - Share state between components by lifting it to their common ancestor\n2. **Keep state local** - Don't make state global unless necessary\n3. **Use appropriate state management** - useState for local, Context for shared, Redux for complex\n4. **Normalize state shape** - Keep state normalized and flat when possible\n5. **Avoid prop drilling** - Use Context API or state management library for deep prop passing\n\n#### Patterns\n\n**Local State (useState)**\n\n- Use for component-specific state\n- Keep it simple and local\n\n**Context API**\n\n- Use for theme, auth, user preferences\n- Split contexts by concern\n- Avoid overusing Context\n\n```tsx\n// ✅ Good: Lifted state\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  return (\n    <>\n      <Child1 count={count} />\n      <Child2 setCount={setCount} />\n    </>\n  );\n}\n\n// ✅ Good: Context for shared state\nconst ThemeContext = createContext();\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState(\"light\");\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n### 4. Component Design\n\n#### Principles\n\n1. **Single Responsibility** - Each component should do one thing well\n2. **Composition over Inheritance** - Use composition to build complex UIs\n3. **Keep components small** - Aim for components under 200 lines\n4. **Use TypeScript** - Type your props and state\n5. **Extract reusable logic** - Create custom hooks for shared logic\n\n#### Patterns\n\n**Container/Presentational Pattern**\n\n- Container: Handles data fetching and state\n- Presentational: Handles UI rendering\n\n**Custom Hooks**\n\n```tsx\n// ✅ Good: Custom hook for reusable logic\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n  const increment = () => setCount((c) => c + 1);\n  return { count, increment };\n}\n```\n\n**TypeScript Props**\n\n```tsx\n// ✅ Good: TypeScript props\ninterface ButtonProps {\n  label: string;\n  onClick: () => void;\n  variant?: \"primary\" | \"secondary\";\n}\n\nfunction Button({ label, onClick, variant = \"primary\" }: ButtonProps) {\n  return (\n    <button onClick={onClick} className={variant}>\n      {label}\n    </button>\n  );\n}\n```\n\n### 5. Testing\n\n#### Guidelines\n\n1. **Test user behavior, not implementation** - Test what users see and do\n2. **Use React Testing Library** - Prefer over Enzyme\n3. **Test accessibility** - Ensure components are accessible\n4. **Mock external dependencies** - Mock API calls, timers, etc.\n5. **Keep tests simple** - One assertion per test when possible\n\n#### Examples\n\n```tsx\n// ✅ Good: Test user behavior\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Button } from \"./Button\";\n\ntest(\"increments counter when clicked\", () => {\n  render(<Button onClick={increment} />);\n  const button = screen.getByRole(\"button\");\n  fireEvent.click(button);\n  expect(screen.getByText(\"Count: 1\")).toBeInTheDocument();\n});\n\n// ✅ Good: Test accessibility\ntest(\"button is accessible\", () => {\n  render(<Button aria-label=\"Submit\" />);\n  expect(screen.getByRole(\"button\", { name: /submit/i })).toBeInTheDocument();\n});\n```\n\n## Additional Resources\n\n- [React Documentation](https://react.dev)\n- [React Patterns](https://reactpatterns.com)\n- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app)\n- [React Testing Library](https://testing-library.com/react)\n\n## Examples\n\n### Example 1: Proper Hook Usage\n\n```tsx\nfunction UserProfile({ userId }: { userId: string }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    async function fetchUser() {\n      setLoading(true);\n      const data = await getUser(userId);\n      if (!cancelled) {\n        setUser(data);\n        setLoading(false);\n      }\n    }\n\n    fetchUser();\n    return () => {\n      cancelled = true;\n    };\n  }, [userId]);\n\n  if (loading) return <div>Loading...</div>;\n  return <div>{user?.name}</div>;\n}\n```\n\n### Example 2: Performance Optimization\n\n```tsx\nconst ExpensiveList = React.memo(({ items }: { items: Item[] }) => {\n  const sortedItems = useMemo(() => {\n    return items.sort((a, b) => a.priority - b.priority);\n  }, [items]);\n\n  return (\n    <ul>\n      {sortedItems.map((item) => (\n        <ListItem key={item.id} item={item} />\n      ))}\n    </ul>\n  );\n});\n```\n",
  "path": "/Users/lekhang/Documents/skills-kit/packages/skills-kit/skills/reactjs-best-practices",
  "installCount": 5626,
  "trendingScore": 61,
  "createdAt": "2025-05-27T18:35:39.417Z",
  "updatedAt": "2025-12-29T06:52:42.903Z"
}